`synchronized`指令用于保证代码的**同步**。编译后，同步块的前后分别生成`monitorenter`和`monitorexit`两个字节码指令，并自动添加**异常处理**指令。对于同一个线程来说，`synchronized`是**可重入**的。

## 语法
### 加在代码块上
```java
Object o = new Object();
synchronized(o) {
    ...
}
```

锁住的是`Object`对象`o`。

### 加在实例方法上
```java
class Demo {
    public synchronized void test() {
        ...
    }
}
```

锁住的是**调用这个方法的实例对象**，即`this`，相当于下面的代码:
```java
class Demo {
    public void test() {
        synchronized(this) {
            ...
        }
    }
}
```

### 加在静态方法上
```java
class Demo {
    public synchronized static void test() {
        ...
    }
}
```

锁住的是**这个方法的所在类的类对象**，即`Class`对象，相当于下面的代码：

```java
class Demo {
    public static void test() {
        synchronized(Demo.class) {
            ...
        }
    }
}
```

## CAS(Compare And Swap)
对于要更新的变量`V`(**Var**)，比较它是否等于预期值`E`(**Expected**)，如果相等，将`V`设置为新值`N`(**New**)，否则放弃更新。

通常用来实现**乐观锁**，在**CPU指令**的层面保证了其**原子性**。

### 问题
#### ABA问题
一个值原来是 A，如果它先变成 B，然后又变成 A，实际变化了两次，但 CAS 无法检测出来。

可以通过**版本号**或者**时间戳**解决。

#### 循环开销大
CAS 常与**自旋**结合，而自选需要消耗大量的**CPU资源**。

可以通过 JVM 提供的`pause`指令缓解。

#### 只能保证一个共享变量的原子操作
CAS 无法同时保证**多个变量**的原子性。

可以把多个变量放入到`AtomicReference`类中，保证对象之间的原子性。

## 对象头(Object Header)
以**32位**虚拟机位例，普通对象的对象头包括32位的 **Mark Word** 与32位的 **Klass Word**，其中 Mark Word 存储对象自身的一些**运行时数据**，Klass Word 则是存储**类型指针**。

```
|----------------------|----------------------|
| Mark Word (32 bits)  | Klass Word (32 bits) |
|----------------------|----------------------|
```

对于数组对象，还需要32位的空间来存储**数组长度**。

```
|----------------------|----------------------|---------------------|
| Mark Word (32 bits)  | Klass Word (32 bits) | arr.length (32bits) |
|----------------------|----------------------|---------------------|
```

Mark Word 的格式如下（*图源:《深入理解Java虚拟机》13.3.4 轻量级锁*）：

![](https://s2.loli.net/2022/07/26/yIgVqbdkG4lFfpY.png)

## 锁优化
### 重量级锁(Heavy-Weight Lock)
JDK1.6 之前，`synchronized`采用的都是重量级锁。

#### Monitor
重量级锁的 Mark Word 指向堆中的 **Monitor 对象**，其内部有如下几个关键字段：

- `Owner` 持有该锁的线程

- `EntryList` 尝试获得锁失败，处于**阻塞**状态的线程

- `WaitSet` 获得了锁之后，又进入了**等待**状态的线程

#### 加锁流程
- 检查锁对象的 Mark Word 指向 Monitor 对象的 Owner 是否为空

    - 若 Owner 为空，则将 Owner 更新为当前线程，表示当前线程持有了重量级锁

    - 若 Owner 非空，说明有其他线程持有重量级锁，当前线程进入 EntryList 阻塞

#### 解锁流程
线程释放锁后，根据调度机制从 EntryList 取出一个线程，将其设置为新的 Owner。

#### 自适应自旋
线程获取锁失败时，并不立刻进入阻塞，而是**自旋重试**一段时间，如果在这段时间里成功获得了锁，就可以避免阻塞。

如果上一次自选成功了，则会将尝试的时间增加，反之亦然。

只有在**多核处理器**下才有意义。

#### 缺点
线程**阻塞**会导致响应时间较为缓慢。

适用于追求**吞吐量**，同步块执行时间**较长**的场景。

### 轻量级锁(Light-Weight Lock)
由经验可得，**对于绝大部分的锁,在整个同步周期内都是不存在竞争的**，使用重量级锁性能太低，为此引入了轻量级锁。

轻量级锁对使用者是**透明的**，语法仍是`synchronized`。

#### 加锁流程

- 检查锁对象，如果处于**未锁定**状态，在当前线程的**栈帧**中新建一个**锁记录**(Lock Record)，存储**当前锁对象的 Mark Word** 的拷贝(记为`Displaced Mark Word`)与**指向锁对象**的引用(记为`Object reference`)

- 用 CAS 操作尝试将对象的 Mark Word 更新为**指向锁记录的指针**

    - 若更新成功，代表线程拥有了这个对象的锁，并将 Mark Word 的最后两位改成`00`，并将`Object reference`用指向锁对象

    - 若更新失败，说明存在锁竞争，检查 Mark Word 是否指向当前线程的栈帧

        - 如果是，说明持有锁的是**当前线程**, 在栈帧中新建一个`Displaced Mark Word`为`null`，`Object reference`指向锁对象的 Lock Record，然后直接进入同步块继续执行

        - 否则说明是**其他线程**持有锁，进行**锁膨胀**，升级成重量级锁

#### 解锁流程
- 找到引用等于当前锁对象的锁记录，检查其`Displaced Mark Word`

    - 如果是`null`，说明有重入，将重入计数减一，并将其`Object reference`设置为`null`

    - 如果非`null`，使用 CAS 尝试将锁记录中的`Displaced Mark Word`**恢复给锁对象**

        - 恢复成功，则解锁成功

        - 恢复失败，说明已经进行了锁膨胀，进入**重量级锁解锁流程**

#### 锁膨胀流程
假设**线程1**持有轻量级锁，当**线程2**加轻量级锁失败时，进入锁膨胀流程：

- **线程2**为锁对象**申请 Monitor 锁**，将锁对象的 Mark Word 更新为 **Monitor 锁的地址**，Owner 更新为**线程1**，并把最后两位改成`10`

- **线程2**进入 Monitor 的 EntryList 阻塞

后续**线程1**解锁时恢复 Mark Word 失败，进入重量级解锁流程。

#### 缺点
**CAS 操作**需要消耗大量 **CPU资源**。

适用于追求**响应时间**，同步块执行速度**较快**的场景。

### 偏向锁(Biased Lock)
为了避免每次重入时都要执行 CAS 操作，引入偏向锁。

#### 加锁流程
- 第一次获得锁时，如果对象锁**可偏向**，使用 CAS 操作将当前线程的**线程id**（不等于 Java 的线程Id）写入 Mark Word 对应位置
 
    - 若写入成功，则加锁成功

    - 否则，撤销偏向锁，升级为**轻量级锁**

之后**相同的线程**再次进入同步块时，仅需新建一个`Displaced Mark Word`为`null`的锁记录，不需要再执行 CAS 操作，直接进入同步块。

#### 解锁流程
将栈中最近的一个锁记录的`Object reference`设置为`null`，不修改 Mark Word。

#### 锁升级流程
- 线程进入同步块时，发现偏向锁的线程id不是自己，使用 CAS 操作尝试替换 Mark Word 中的线程id为自己的线程id

    - 若替换成功，说明之前的线程不存在了，锁仍然为偏向锁，不升级，相当于一次**重偏向**
    
    - 否则，升级为轻量级锁，再按照轻量级锁进行竞争

#### 锁撤销
除了竞争会导致偏向锁撤销之外，还有其他行为会导致锁撤销：

- 调用了对象的`hashCode`方法，没有地方存储 hashCode

    - 轻量级锁在**锁记录**中存储 hashCode

    - 重量级锁在 **Monitor** 中存储 hashCode

- 调用 `wait`/`notify`函数

#### 批量重偏向与批量撤销

每个类维护一个**偏向锁撤销计数器**，每一次该类的对象发生**偏向撤销**操作时，计数器+1。

当计数器达到一定值（默认20），JVM 会进行**批量重偏向**，将偏向锁偏向另一个线程。

当计数器达到一定值（默认40），JVM 会进行**批量撤销**，将**整个类**设置为**不可偏向**。

#### 缺点
锁撤销的过程需要 **STW**，开销较大。

适用于**只有一个线程**访问同步块的场景。
