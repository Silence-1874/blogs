> 若无特别说明，本系列提到的Java版本均为8，JVM均为HotSpot

## 判断对象是否存活
### 引用计数法(Reference Counting)
给对象添加一个**引用计数器**，计数器为 0 则对象死亡。

- 优点

  - 原理简单，效率高

- 缺点

  - 增加了**空间**（存储计数器）与**时间**（维护计数）的开销

  - 难以解决对象相互**循环引用**问题，JVM 不采用

### 可达性分析算法(Reachability Analysis)
通过`GC Roots`根对象作为起始节点集，从`GC Roots`到某对象不可达，则该对象死亡。

可作为`GC Roots`的对象：

- 虚拟机栈中引用的对象（方法参数、局部变量、临时变量）

- 类静态属性引用的对象（引用类型静态变量）

- 常量引用的对象（ StringTable 的引用)

- JNI( Native 方法)引用的对象

- JVM 内部的引用（基本数据类型的 Class 对象、常驻异常对象、系统类加载器）

- 被同步锁( synchronized 关键字)持有的对象

### 四种引用类型
#### 强引用(Strongly Reference)
代码中普遍存在的**引用赋值**，其引用的对象永远不会被回收。

#### 软引用(Soft Reference)
系统在**将要发生 OOM 前**，将软引用的对象进行回收，可用于**高速缓存**。

#### 弱引用(Weak Reference)
只要**垃圾收集器开始工作**，弱引用就会被回收，无论内存是否足够，可用于可有可无的**缓存**。

#### 虚引用(Phantom Reference)
不会对对象造成任何影响，也不能通过虚引用获得对象实例，只为了在被回收时收到系统通知，必须和**引用队列**一起使用，可用于**资源释放**。

#### 终结器引用(Final Reference)
用于实现对象的`finalize()`方法，配合**引用队列**使用。

### 类型卸载
大量使用**反射、动态代理、CGLib 等字节码框架、动态生成 JSP 以及 OSGi** 等**频繁自定义类加载器**的场景中需要类型卸载。

类回收的条件：

- 该类的**所有实例**已被回收

- 该类的**类加载器**已被回收（很难达成）

- 该类对应的`java.lang.Class`对象没被引用

## 垃圾收集算法
### 标记-清除(Mark-Sweep)算法
首先标记出所有**需要回收的对象**，在**标记完成后**，**统一回收**所有被标记的对象。（也可以反过来标记存活的对象）

缺点：

- 执行**效率不稳定**，随对象数量增长而下降

- 存在内存空间**碎片化**问题

- 需要**全程暂停用户应用程序**，即 **Stop The World (STW)** 。

### 标记-复制(Mark-Copy)算法
将新生代分为较大的 **Eden** 空间和两块较小的 **Survivor** 空间，三者大小比为**8:1:1**。分配内存只使用 Eden 和其中一块 Survivor ，垃圾收集时，将 Eden 和 Survivor 中仍存活的对象复制到另一块 Survivor 空间上，并清理掉 Eden 和原来的 Survivor 空间。

当 Survivor 容不下一次 Minor GC 后存活的对象时，需要依赖其他内存区域（老年代）进行**分配担保**(Handle Promotion)。

- 优点

  - 不需要标记，效率相对最高

  - 没有碎片问题

- 缺点

  - 对象**存活率较高**时复制操作效率低，因此不适用于老年代

  - 会浪费较多空间

### 标记-整理(Mark-Compact)算法
垃圾收集时，将所有存活的对象向内存空间一端**移动**，清理掉边界外的内存。

- 优点

  - 分配新对象时，只需要记录内存的**起始地址**

- 缺点

  - 效率相对最低

  - 移动时需要**STW**

  - 移动对象时，还需要调整**引用**的地址

### 分代收集(Generational Collection)
将 Java 堆**划分出不同的区域**，将回收对象依据**年龄**分配到不同的区域中存储。

通常分为**新生代**(Young Generation)和**老年代**(Old Generation)，默认情况下大小为**1:2**。

#### 三个基本假说
1. **弱分代假说**(Weak Genearational Hypothesis)：绝大多数对象都是朝生夕灭的

2. **强分代假说**(Sring Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡

3. **跨代引用假说**(Intergenerational Reference Hypothesis)：跨代引用相对于同代引用占少数

#### GC 分类
- **部分收集**(Partial GC)

  - **新生代收集**(Minor GC/Youn GC)：**新生代**的垃圾收集

  - **老年代收集**(Major GC/Old GC)：**老年代**的垃圾收集

  - **混合收集**(Mixed GC)：收集**整个新生代**和**部分老年代**

- **整堆收集**(Full GC)

#### 跨代引用问题
在新生代上建立一个全局数据结构**记忆集**(Remembered Set)，把**老年代**分为若干小块，识别出哪一块会存在跨代引用，在**Minor GC**时仅将这些小块里的对象加入到 GC Roots 进行扫描。

## 内存分配和回收原则
- 对象优先在 **Eden 区**分配，若 Eden 区空间不足，进行 **Minor GC**

- **大对象**直接进入**老年代**，避免其产生的**高额复制开销**

- 对象在 **Survivor 区**中每熬过一次 Minor GC，年龄就增加一岁，到一定岁数（默认为15）就会晋升到**老年代**

- Survivor 区中**不大于某年龄**的所有对象大小总和大于 Survivor 空间的一半，则**不小于此年龄**的对象可以直接进入老年代

- Minor GC 前，若**老年代最大可用连续空间**大于**新生代所有对象总空间**，则可以确保安全。否则，继续检查**老年代最大可用连续空间**是否大于**历次晋升到老年代对象的平均大小**，大于则进行 Minor GC，否则可能进行 **Full GC**

## 经典垃圾收集器
### Serial & Serial Old 
- **单线程**工作：仅使用**一个**收集器线程进行垃圾收集，且在收集时**需要 STW**

- **新生代**采取**复制**算法，**老年代**采取**整理**算法

- 简单高效

### ParNew 
- Serial 收集器的**并行**版本，使用**多个**收集器线程进行垃圾收集，且在收集时**需要 STW**

- 默认开启的收集线程数与**处理器核心数**相同

### Parallel Scavenge & Parallel Old
- 和 ParNew 收集器类似，但关注点是**吞吐量**（处理器用于**运行用户代码**的时间与处理器**总消耗**时间的比值）

- **新生代**采取**复制**算法，**老年代**采取**整理**算法

- Java8 的**默认**垃圾收集器组合

### CMS(Concurrent Mark Sweep)
- 关注点是**获取最短回收停顿时间**，低延迟

- 基于**标记-清除**算法，并发收集

- 主要运用于**老年代**

#### 运作过程
1. **初始标记**(CMS initail mark)：需要 STW ，标记 GC Roots **直接关联**的对象，速度很快

2. **并发标记**(CMS concurrent mark)：不需要 STW ，从上一步标记的对象开始**遍历整个对象图**，花费时间长

3. **重新标记**(CMS remark)： 需要 STW ，采用**增量更新**修正上一步中间**产生变动**的标记，比第一步稍长

4. **并发清除**(CMS concurrent sweep)： 不需要 STW ，清理标记阶段判断的已死亡对象

#### 缺点
- 对**处理器资源**非常敏感

- 可能出现**浮动垃圾**，需要**预留**一部分空间供**并发收集的程序**运作使用，以免出现 Full GC

- 标记-清除算法会**产生大量空间碎片**

### G1(Garbage First)
- **面向局部收集**，同时兼顾新生代与老年代，收集衡量标准为哪块内存存放的垃圾最多

- 基于 **Region** 的内存布局形式，将堆空间划分为**多个大小相等的独立区域**(Region)，每个 Region可以根据需要作为新生代或老年代的一部分

- **大对象**存储在 **Humongous Region**，G1 一般将 Humongous Region 当作**老年代**的一部分看待

- 主要用于**服务端**应用

#### 运作过程
1. **初始标记**(Initial Marking)：需要 STW，标记 GC Roots **直接关联**的对象

2. **并发标记**(Concurrent Marking)：不需要 STW，从上一步标记的对象开始**遍历整个对象图**

3. **最终标记**(Final Marking)：需要 STW， 处理上一步遗留下来的少量**快照记录**

4. **筛选回收**(Live Data Counting and Evacuation)：需要 STW,计算各个 Region 的**回收价值和成本**并排序，制定回收计划，将决定回收的 Region 复制到空 Region 并清理

#### 特点
- 不会产生空间**碎片**

- 有**可预测的时间模型**

- **内存占用**和**执行负载**较高