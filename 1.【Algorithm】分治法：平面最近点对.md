> 本文是我大二下时《算法设计与分析》课程的第一个实验作业，第一个作业还是花了不少心思认真写了写的（后面的作业就随便水了），因此也放在这里做个记录。

## 实验内容

给定平面上n个点的集合S，找其中的一对点，使得在n个点组成的所有点对中，该点对间的距离最小。 

(可能存在多对相同的最近点对，简单起见，本次实验仅计算其中一对；此外，假设输入点的个数大于等于2)


## 实验环境
- 系统环境：`Windows 10 Pro 21H2`
- 编程语言：`Java`
- JDK版本：`11.0.13`
- 集成开发环境：`IntelliJ IDEA 2020.3`
- 可视化工具：`Java Swing`
- Java程序打包exe工具：`exe4j 6.0.1`
- Markdown格式转换工具：`pandoc 2.16.2`

## 实验分析
假设对于给定的点集P，记为 $P_1$, $P_2$, $P_3$, ... , $P_n$     $n>1$

### 一维问题分析
首先从一维情况开始考虑，即寻找一条直线上的最近点对。

#### 枚举法
双重循环，列举出直线上每一组点对 $ (P_i, P_j) $, 计算并维护最小距离。

伪码描述如下：

```C
for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) 
        ans = min(ans, dis(p[i], p[j]);
```

#### 分治法
分治法的思路也很清晰，对直线上的点**一分为二**，分别找出**两边各自的最近点**（通过递归解决），然后找出**跨界**的最近点对。寻找跨界最近点对，只需要找到左侧最靠近分界线的点，以及右边最靠近分界线的点，这两个点便是跨界的最近点对，将这两个点的距离与两边各自的最近点对比较，返回**三者之中的最小值**即可。

伪码描述如下：

```C
divide(start, end) {
    mid = (start + end) >> 1;
    leftMin = divide(start, mid - 1);
    rightMin = divide(mid + 1, end);

    d = min(PRight) - max(PLeft);
    return min(leftMin, rightMin, d);
}
```

一维情况难度不大，下面重点分析二维平面上的最近点对。

### 二维问题分析
#### 枚举法
双重循环，列举出平面内每一组点对$ (P_i, P_j) $，计算并维护最小距离 $d_{min}$ 。
伪码描述如下（具体实现见源码文件）：
```C
for (int i = 0; i < n; i++)
    for (int j = i + 1; j < n; j++) 
        ans = min(ans, dis(p[i], p[j]);
```
虽然是暴力法，仍有两个细节可以注意：
1. 第二层循环`j`可以从`i+1`开始，能避免 $(P_i,P_j)$ 与 $(P_j,P_i)$ 这样相同的两个点重复计算。
2. `getDistance()`在整个算法中调用频率较高，`sqrt()`函数本身又比较影响性能（尤其在JDK源码中，sqrt是通过纯迭代来实现的）。因此，在`getDistance()`的实现中，并不计算开方的结果，而是直接返回距离的乘积，将开方计算推迟置`gui.Panel`的`print()`函数里，在最后的数据展示中调用`sqrt()`，而不必在函数内开方。通过这种推迟计算的方法，可以在一定程度上提高程序整体的运行速度。
> 这里笔者“聪明反被聪明误"了，第二个优化操作给后面分治法的实现留下了一个大bug，导致笔者检查了三天才找出来。详情见最后的“实验总结”。

以上两个小改动虽然能起到一定的效果，但由于双重循环的存在，暴力枚举法的平均时间复杂度依然是 $O(n^2)$。 

下面分析重点分治法。

#### 分治法
##### 算法总体思路：
1. 将点集一分为二，划分后的左右两个点集分别记为`PLeft`、`PRight`。
    伪码描述如下（具体实现见源码文件）：
  ```C
  mid = size / 2;
  PLeft = points[0]……points[mid];
  PRight = points[mid + 1]……points[size - 1];
  ```
2. 通过递归分别计算 `PLeft` 与 `PRright` 两个子点集各自的最近点对距离，记为`leftMin`与`rightMin`。
    伪码描述如下（具体实现见源码文件）：
  ```C
  leftMin = recurse(PLeft);
  rightMin = recurse(Pright);
  ```
3. 计算位于分界线两边的点的（跨界）最近点对距离，记为`d`。
4. 比较`leftMin`, `rightMin`, `d`三者的大小，取三者中的最小值作为返回值。
5. 分治递归，处理子问题，最终得到结果。
##### 一些细节:
- 确定递归出口(最小子问题): 对**只有两个点**与**只有三个点**的情况单独处理。
  - 2个点: 无需再分，直接返回`getDistance(p1, p2)`。
  - 3个点: 对这三个点两两一组，分别计算距离，取最小的距离作为返回值。
  伪码描述如下（具体实现源码文件）：
  ```C
  if (n == 2) 
    return getDistance(p1, p2);
  else if (n == 3) 
    return min(getDistance(p1, p2), getDistance(p1, p3), getDistance(p2, p3));
  ```
- 第一步将一分为二时，应尽量让 `PLeft` 与 `PRright` 大小相等，有助于降低分治整体的时间复杂度。
  因此，最好以中点为分界点，将当前整个点集**平均分**。要快速找到中点，需要对点集进行预处理，即按横坐标排序。
- 第三步是最关键的。最直接的想法是将所有左侧的点逐一与右侧的点配对，计算距离，但这样时间复杂度就是 $O(n^2)$，甚至不如暴力搜索。事实上，由于是取三者**最小值**，若 $d>\delta$，则d不可能成为三者中的最小值。因此可以考虑尝试把**可能存在的跨界最短点对**限制在某个较小范围内。
  记分界线的横坐标为`m`：
  
  - 考虑极限情况，有点正好落在分界线上，可以把范围缩小在分界线左右两侧 $\delta$ 之内，即：
    $$
    [x - \delta, x + \delta]
    $$
  - 进一步尝试缩小范围。对于左侧某点 $p$ ,尝试以该点画圆，则符合条件的点仅可能落在右侧的弓形之中。
  - 考虑到计算圆上某点难度较大，再次尝试缩小范围。作一个长为 $2\delta$ 宽为 $\delta$ 的矩形，将这个矩形平均分成6个小矩形，由勾股定理易得小矩形的对角线长度为 $\frac{5}{6}\delta$，小于 $\delta$，而矩形内对角线又是最长的线段，因此一个小矩形内不可能同时存在2个及以上的点。由**鸽笼原理**可得，大矩形内最多只存在6个点。因此，对于左边的每个点 $p$ ，**只需要验证其上下 $\delta$ 范围内的6个点即可**。如下图所示。
  ![](img/2022-03-17-23-18-29.png)
  - 接下来的问题是如何快速找到这6个点。对于给定的一个点p，先找到纵坐标大于`y - d`的最小的点 *（`Java Swing`中y轴是向下的，简单起见，这里的描述一律以二维笛卡尔坐标系为准）* ，然后依次枚举之后的连续6个点即可。因此还需要对右侧的点按y轴进行排序。（此处可用二分查找优化）
##### 时间复杂度分析:
**主要耗时操作**
- 对整体按横坐标排序(Java库函数`sort()`)：$O(n\log n)$![](img/202203202256284.png)
- 递归处理两边子问题:  $2T(n/2)$![](img/2022-03-20-23-02-37.png)
  
- 寻找跨界点对:  $O(n)$![](img/2022-03-20-23-04-33.png)
  
- 对`PRight`中的点按纵坐标排序: $O(n\log n)$![](img/202203202256284.png)

总体时间复杂度

$$
T(n)=
\begin{cases}
1, & \text{} n \leq 3\\
2T(n/2) + O(n) & \text{} n > 3
\end{cases}
$$

解得

$$
\begin{aligned}
T(n) = O(n * \log n * \log n)
\end{aligned}
$$

**进一步优化**
在子问题的处理中，每次都要对x和y排序，事实上，这一部分和子问题的处理联系不大，可以移置递归函数外提前处理完。即，维护两个排序的子集，一个按横坐标排序，用于均分点集；另一个按纵坐标排序，用于快速找出那关键的6个点。

伪码描述如下（具体实现源码文件）：
```C
// 从按纵坐标排序的点集中筛选出两侧的带型区点集，放在同一个集合中
// 注意，这里不再区分左右两边
for (p in ySortedPoints)
    if (|p.x - mid.x| <= d)
        curList.add(p);

// 对筛选出的点集中的所有点进行检查
for (p in curList)
    for (p’ in {p之后的6个点}) 
        d = min(d, getDistance(p, p’);
```

经过预处理，将子问题的时间复杂度 $O(n\log(n))$ 降低至 $O(n)$。
最终优化得到的时间复杂度为：
$$
\begin{aligned}
O(n\log n)
\end{aligned}
$$
至此，本实验分析完毕。
## 实验总结/感想
在分治法中，一开始我依然将计算距离函数中的开方推迟到最后，结果每次计算出的距离都是实际距离的平方值，在比较过程中并没有什么影响，但是在收集分界线两侧带型点集时，因为要计算在 $\delta$ 内的点集，此时就必须要使用实际值了，除非在计算的时候将分界线的横坐标也一起开方。稳妥起见，我还是将开方操作放在了计算两点距离的函数之内。

本题的分治法本身不算太难，但有诸多细节需要注意，稍有不慎便谬之千里。

由于点都是随机生成的，遇到bug时难以复现。一些细节上的错误会导致bug时隐时现，很难调试，只能每次把随机生成的点集打印出来，遇到bug时再手动生成出错的那次点集，非常繁琐。

分治法非常巧妙，最关键的就在于中间部分。正如归并排序中，关键在于两个部分的合并一样。

从此题中也可以看出随着维度的升高，算法实现的难度也大大增加。一维的最近点对很容易，寻找跨界最近点对时只需要两个点就可以确定，而到了二维，就需要做如此多的计算与思考。无法想象三维空间中又有哪些奇技淫巧。

由于笔者也是第一次使用Java的GUI库进行可视化，期间也是一边查手册一边写代码，虽然依旧有不少Bug，但勉强也能用。鉴于本次实验重在算法分析，便不再死抠自己写的有关GUI的Bug了。

在查找资料的过程中，发现一篇论文：

*周玉林,熊鹏荣,朱洪.求平面点集最近点对的一个改进算法[J].计算机研究与发展,1998(10):93-97*

其中提到，在考察带型左半区域中的每个点p时，只需检验右半带域的至多4个点即可。
由于笔者精力与时间有限，故依然采用传统的6个点的算法，以后有空再做深入研究吧。