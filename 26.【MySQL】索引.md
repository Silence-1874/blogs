### 索引定义
索引是一种为了**加快数据查询速度**的**数据结构**。

### 索引分类
#### 按数据结构
常见的有`Hash索引`、`B树索引`、`B+树索引`。

**InnoDB存储引擎**采用的是**B+树**索引，特点如下：

- **数据**都存储在**叶子结点**中，非叶子节点仅存储**索引值**

- 叶子结点用**双链表**连接

- 结点内可以使用**二分查找**查找数据

相比Hash索引：

- B+树索引支持**顺序查询和范围查询**

- B+树索引没有**Hash冲突**问题

相比B树索引：

- B+树索引在**相同树高度**下，能够存储更多数据，减少了IO次数

- B+树的**查询效率稳定**，都是从根节点到叶节点

- B+树的数据都在叶子节点中，便于**范围查询**

#### 按字段特性
- `主键索引(Primary Index)` 建立在**主键字段**上，一张表最多只有一个主键索引。

- `唯一索引(Unique Index)` 建立在**UNIQUE字段**上，值必须唯一

- `普通索引 ` 建立在**普通字段**上的索引

- `前缀索引` 建立在**字符类型**字段的**前几个字符**上

#### 按物理存储
分为**聚簇索引**(Clustered Index)和**二级索引**(Secondary Index)。

**InnoDB引擎**中，每一个表都有聚簇索引，生成规则如下：

1. 如果存在**主键索引**，则使用主键索引作为聚簇索引

2. 否则，使用第一个**非空**的**唯一**索引作为聚簇索引

3. 若以上均不存在，自动建立一个叫做`GEN_CLUST_INDEX`的聚簇索引

聚簇索引存储了**所有字段** 的值，二级索引仅存储**索引值**与对应的**主键值**。

#### 按字段个数
分为**单列索引**与**联合索引**。

单列索引建立在一个字段上，联合索引建立在多个字段上。

### 索引覆盖
在**二级索引**上的字段覆盖了所有**查询所需**的字段，**避免回表操作**。

### 索引下推
扫描二级索引时，直接对其中的字段进行条件判断，**提前过滤**不符合条件的记录，减少回表次数。

### 最左前缀匹配
使用联合索引时，这个索引的任何一个最左前缀都会被用于优化查询，直到某一列的查询条件无法用索引优化。

### 索引设计原则
- 选择数据区分度较大的字段建立索引，建立联合索引时，也要将区分度较大的字段放在左边

- 选择查询多，更新少的字段建立索引

- 不要建立太多索引，一来会造成冗余，二来选择合适的索引也需要时间

- 对字符串类型数据建立索引时，尽量使用前缀索引

- 尽可能建立联合索引

- 主键索引尽量自增，减少页分裂

### 索引失效情况
- 使用**左模糊匹配**或**全模糊匹配**，即`LIKE "%pattern"`或`LIKE "%pattern%"`

- 对索引列**使用函数**或进行**运算**

- 索引列发生了**隐式类型转换**，例如字符串没加引号（但是给数字强行加上引号却没关系，因为MySQL会**自动把字符串转成数字**，再进行比较）

- 对联合索引中某列进行**范围查询**，**其后**的索引失效

- `OR`语句中，**至少**有一个条件没有用到索引，所有索引失效

### EXPLAIN命令
使用方法：直接在语句前加上**EXPLAIN**

以我的博客项目中最复杂的这个SQL语句为例：

```sql
SELECT * 
  FROM blog 
 RIGHT JOIN blog_tag 
    ON blog.id = blog_tag.blog_id 
 RIGHT JOIN tag 
    ON tag.id = blog_tag.tag_id 
 WHERE tag.id = 1
 ORDER BY is_top DESC, 
          create_time DESC, 
          update_time DESC
```

执行`EXPLAIN`命令后，结果如下：

![](https://s2.loli.net/2022/07/10/nqIsERjXiCvlHb4.png)

### 输出结果分析
#### Id
每一个独立的查询对应一个唯一的Id值。

- id相同，执行顺序从上到下

- id不同，执行顺序从Id值较大的到Id值较小的

#### select_type
表示SELECT的类型，常见值如下：

- `SIMPLE` 简单查询，不包含**子查询**或**UNION**

- `PRIMARY` 复杂查询的**主查询**，即**最外层**的部分

- `SUBQUERY` 在**SELECT**或**WHERE**中的子查询

- `DERIVED` 在**FROM**中的子查询

- `UNION` 在**UNION**后除最外层查询的部分

#### table
查询的表名，可能为**别名**或**临时表**。

#### partitions
查询匹配的分区。

#### type
查询的类型，按照性能从优到差为：

`system` > `const` > `eq_ref` > `ref` > `ref_or_null` > `index_merge` > `unique_subquery` > `index_subquery` > `range` > `index` > `ALL`

- `system` 表中**只有一条记录**

- `const` 使用**主键索引**或**唯一索引**进行**等值匹配**

- `eq_ref` **连接查询**中，**被驱动表**使用**主键索引**或**唯一索引**进行**等值匹配**
 
- `ref` 使用**普通二级索引**进行**等值匹配**

- `ref_or_null` 同上，但索引列的值可以为`null`。

- `index_merge` 使用了**索引合并**进行优化

- `unique_subquery` 在 **`IN`子查询** 中使用**主键索引**或**唯一索引**进行**等值匹配**

- `index_subquery` 同上，但使用的是**普通二级索引**

- `range` 在索引上进行**范围查询**

- `index` 在索引上进行**全表扫描**

- `ALL` 普通**全表扫描**

根据*阿里巴巴Javak开发手册（嵩山版）*，SQL优化至少要达到`range`级别，要求是`ref`级别，最好可以达到`const`级别。

#### possible_keys
**可能**使用到的索引。

#### key
**实际**使用的索引。

#### key_len
使用的**索引列**的长度。

#### ref
等值匹配的对象，常见值有`const`(常量)，`func`(函数)，字段名和`null`。

#### rows
预计要扫描的行数。

#### filtered
驱动表的**扇出值**，表示表中**符合条件的记录**的百分比。

#### Extra
额外信息，常见值如下：

- `Using index` 使用了**覆盖索引**

- `Using where` 某个搜索条件需要在**server**层进行判断

- `Using filesort` 使用了**外部排序**（即无法使用索引排序）

- `Using temporary` 产生了**临时表**

- `Using index condition` 使用了**索引下推**