> 若无特别说明，本系列提到的Java版本均为8，JVM均为HotSpot

类的生命周期分为**加载、验证、准备、解析、初始化、使用和卸载**七个阶段，*验证、准备、解析*统称为**连接**。

加载、验证、准备、初始化和卸载按顺序**开始**，并**交叉进行**。解析的顺序不一定。

## 类加载时机
- 使用`new`关键字实例化对象

- **读取**或**设置**一个类的**静态字段**（被`final`修饰的**基本数据类型**与**字符串**除外）

- 调用一个类的**静态方法**

- 对类进行**反射调用**

- **父类先于子类**初始化

- 包含`main()`方法的**主类**在虚拟机启动时会先初始化

### 被动引用
**不会触发初始化**的引用类型称为**被动引用**，如下面几种情况：

- 通过**子类**引用**父类静态字段**，**子类**不会初始化

- 通过**数组**定义引用类，**该类**不会初始化

- **常量**在**编译阶段**会存入**常量池**中，**定义常量的类**不会初始化

- **父接口**不会先于**子接口**初始化，**真正使用到父接口**才会初始化

## 类加载过程
### 加载(Loading)
- 通过类的全限定名获得定义此类的**二进制字节流**

- 将这个字节流代表的**静态存储结构**转化为方法区的**运行时数据结构**

- 在**堆**内存中生成该类的`java.lang.Class`对象

### 连接(Linking)
#### 验证(Verification)
确保`Class`文件符合《规范》要求，是一个重要但非必须的阶段。

主要有以下四个步骤：

- **文件格式验证**：验证**字节流**是否符合`Class`文件格式的规范。通过此验证后，字节流才**被允许进入方法区**

- **元数据验证**：对字节码描述的信息进行**语义分析**，类的**元数据**信息进行**语义校验**

- **字节码验证**：对类的**方法体**进行校验分析，确保**程序语义**合法。通过此验证后，也**不能确保完全安全**

- **符号引用验证**：对**类自身以外**的各类信息进行匹配校验，确保**解析行为**和正常执行

#### 准备(Preparation)
为**类中定义的变量**（**静态变量**）分配内存并设置初始值。

#### 解析(Resolution)
将常量池内的**符号引用**替换为**直接引用**。

- 类或接口的解析

- 字段解析

- 方法解析

- 接口方法解析

### 初始化(Initialization)
真正开始执行类中编写的 **Java 程序代码**，将主导权交给**应用程序**。

是执行类构造器`<clinit>()`方法的过程。

#### \<clinit>()方法
- 由**编译器**自动收集类中的所有**类变量的赋值动作**和**静态语句块**中的语句合并产生，按照语句在**源文件中出现的顺序**收集

- 静态语句块只能访问**定义在其前的变量**，其后的变量可以**赋值**，但**不能访问**

- JVM 保证父类的`<clinit>()`**先于子类执行完毕**，因此第一个执行的一定是`java.lang.Object`的`<clinit()`方法

- **父类**定义的**静态语句块**要优先于**子类**的**变量赋值操作**

- 如果类中没有静态语句块，也没有对变量的赋值操作，可以不生成`<clinit>()`方法

- 接口的`<clinit>()`方法不需要先执行父类

## 类加载器
实现 *“通过一个类的**全限定名**来获取描述该类的**二进制字节流**”* 的代码。

比较两个类是否“相等”，只有在这两个类是由**同一个类加载器加载**的前提下才有意义。

### 分类
#### 启动类加载器(Bootstrap Class Loader)
- 用 **C++** 实现，是 JVM 自身的一部分，无法被 Java 程序直接引用

- 加载`<JAVA_HOME>\lib`目录，或被`-Xbootclasspath`参数指定的路径下的类库

#### 扩展类加载器(Extension Class Loader)
- 用**Java**实现，继承自抽象类`java.lang.ClassLoader`

- 加载`<JAVA_HOME>\lib\ext`目录，或被系统变量`java.ext.dirs`指定的路径下的类库

#### 应用程序类加载器(Extension Class Loader)
- 用**Java**实现，继承自抽象类`java.lang.ClassLoader`

- 加载**用户类路径**下的类库，是**默认**的类加载器

#### 用户自定义类加载器(User Class Loader)
- 用户自己定义的类加载器

### 双亲委派模型(Parents Delegation Model)
- 除顶层的启动类加载器外，其余的类加载器都有自己的父类加载器

- 父子关系是**组合(Composition)**，而非**继承(Inheritance)**。

#### 工作过程 
一个类加载器收到类加载请求时，不会先自己尝试加载这个类，而是**把这个请求委派给父类加载器**去完成，每一层都是如此，所有加载请求**最终都应该传到启动类加载器中**，只有当父类无法加载这个类时，子加载器才尝试完成加载。

#### 好处
Java 中的类随着它的类加载器一起具备了一中**带有优先级的层次关系**，例如`java.lang.Object`，最终都委派给启动类加载器进行加载，从而使`Object`在各种类加载器环境下保证是同一个类，有利于保证程序的**稳定运作**。