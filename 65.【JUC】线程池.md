> 若无特别说明，博客中的JDK源码均来自`OracleJDK-1.8.0_311`

线程通过`start()`创建启动，执行完`run()`方法后自动销毁，而创建线程涉及到系统调用，是一个**重量级**的操作，为避免频繁创建与销毁线程带来的资源消耗，方便管理线程，引入**线程池**。

## Executor 接口
将任务的**提交**和**执行**解耦，其中只有一个方法：

```java
void execute(Runnable command);
```

接收`Runnable`对象，可以自己执行，也可以交给其他线程执行。

## ExecutorService 接口
对`Executor`做了进一步的扩展，引入了线程池的**状态**，以及可以返回`Future`的一系列`submit`方法。

![](https://s2.loli.net/2022/08/09/Qie7ug41cIH6S3D.png)

## AbstractExecutorService 抽象类
对`ExecutorService`的方法提供了了基本实现，引入`newTaskFor`方法，利用`FutureTask`统一接收`Runnable`对象与`Callable`对象。

## ThreadPoolExecutor
线程池中最主要的类，继承了`AbstractExecutorService`抽象类，继承关系图如下：

![](https://s2.loli.net/2022/08/09/iBPxUnhAjWwKEYg.png)

### 属性
#### ctl
```java
// 封装了两个变量：runState 和 workerCount
// 可以通过一次 CAS 操作同时更新两个变量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```

#### COUNT_BITS
```java
// ctl的高3位表示线程状态，低29位表示工作线程的数量
private static final int COUNT_BITS = Integer.SIZE - 3;
```

#### CAPACITY
```java
// 最大线程数
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
```

#### RUNNING
```java
// 运行态(111)
// 可接受任务，可处理阻塞队列中的任务
private static final int RUNNING    = -1 << COUNT_BITS;
```

#### SHUTDOWN
```java
// 关闭态(000)
// 不可接受任务，可处理阻塞队列中的任务
private static final int SHUTDOWN   =  0 << COUNT_BITS;
```

#### STOP
```java
// 停止态(001)
// 不可接受任务，也不可处理阻塞队列中的任务，并暂停所有正在执行的任务
private static final int STOP       =  1 << COUNT_BITS;
```

#### TIDYING
```java
// 完成态(010)
// 所有任务结束，workerCount 为 0
private static final int TIDYING    =  2 << COUNT_BITS;
```

#### TERMINATED
```java
// 终结态(011)
// TYDYING 状态下调用 terminated() 方法进入
private static final int TERMINATED =  3 << COUNT_BITS;
```

#### workQueue
```java
// 阻塞队列。存储提交的任务
private final BlockingQueue<Runnable> workQueue;
```

#### mainLock
```java
// 锁
private final ReentrantLock mainLock = new ReentrantLock();
```

#### workers
```java
// 工作线程的集合，持有 mainLock 才可访问
private final HashSet<Worker> workers = new HashSet<Worker>();
```

#### termination
```java
// 等待终结的条件变量
private final Condition termination = mainLock.newCondition();
```

#### largestPoolSize
```java
// 最大线程数，持有 mainLock 才可访问
private int largestPoolSize;
```

#### completedTaskCount
```java
// 已完成的任务数量，持有 mainLock 才可访问
private long completedTaskCount;
```

#### threadFactory
```java
// 线程工厂
private volatile ThreadFactory threadFactory;
```

#### keepAliveTime
```java
// 阻塞队列中的线程最长保活时间（单位：纳秒）
private volatile long keepAliveTime;
```

#### allowCoreThreadTimeOut
```java
// 如果为 false ，阻塞队列中的线程永久保活
// 如果为 true，阻塞队列中的线程空闲超过 keepAliveTime 后销毁
// 通常线程数超过 corePoolSize 时才会触发
private volatile boolean allowCoreThreadTimeOut;
```

#### corePoolSize
```java
// 核心线程数
private volatile int corePoolSize;
```

#### maximumPoolSize
```java
// 最大线程数
private volatile int maximumPoolSize;
```

#### handler
```java
// 拒绝策略
private volatile RejectedExecutionHandler handler;
```

#### defaultHandler
```java
// 默认拒绝策略（抛出异常）
private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
```

### 构造方法
```java
public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            Executors.defaultThreadFactory(), defaultHandler);
}

public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            threadFactory, defaultHandler);
}

public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            Executors.defaultThreadFactory(), handler);
}

// 上面所有的构造函数最终都是调用此构造函数
public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

### Worker 内部类

### 执行任务
```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();

    int c = ctl.get();
    // 当前线程数小于核心线程数，增加一个工作线程
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
```