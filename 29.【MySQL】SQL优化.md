### INSERT
将多条插入语句整合到一条插入一句中。

### ORDER BY
- 在要排序的字段上加上**索引**，满足最左匹配原则

- 如果有多个排序条件，尽量**都为升序**或**都为降序**

- 可以适当增加**排序缓冲区**大小`sort_buffer_size`，其默认值为256k

- 允许的情况下尽量把排序放到**程序端**

### GTROUP BY
基本跟**ORDER BY**一样。**GROUP BY**是先排序后分组。

### LIMIT
在索引上分页操作，再根据主键关联回原表查询所需的其他字段，如下

```sql
SELECT * 
  FROM student t, (    
        SELECT id 
          FROM student 
         ORDER BY id 
         LIMIT 2000000, 10
        )
 WHERE t.id = a.id
```

### COUNT
性能排序：`COUNT(普通字段，无索引)` < `COUNT(主键)` < `COUNT(1)` = `COUNT(*)`。

#### COUNT(普通字段，无索引) 
- 字段没有`not null`约束：将表中的所有字段值取出，发送给服务层，由服务层判断是否为`null`，不是`null`则计数加1。

- 字段有`not nu1l`约束：将表中的所有字段值取出，发送给服务层，每读到一条记录，就将计数加1。

#### COUNT(主键)
- 将表中的所有主键值取出，发送给服务层，由服务层判断是否为`null`（其实主键字段肯定不为`null`，但InnoDB并没有优化），不是`null`则计数加1。

- 如果表中有二级索引，会优先遍历二级索引（IO成本更小）。

#### COUNT(1）
- 遍历整张表，但不取值，每读到一条记录，就将计数加1。

- 如果表中有二级索引，会优先遍历二级索引（IO成本更小）。

#### COUNT(*) 
等同于`COUNT(1)`。

### UPDATE
更新时尽量使用有效的索引，避免将表中所有记录都锁住，使更新语句整体效率变低。